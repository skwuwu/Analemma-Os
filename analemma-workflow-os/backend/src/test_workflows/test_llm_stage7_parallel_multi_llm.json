{
    "workflow_name": "LLM Stage 7 - Parallel Multi-LLM + StateBag Merge",
    "description": "ë™ì‹œ ë‹¤ì¤‘ LLM í˜¸ì¶œì—ì„œ ìƒíƒœ ê²©ë¦¬ ë° ê²°ê³¼ ë³‘í•© ê²€ì¦",
    "version": "2.1.0",
    "test_stage": 7,
    "nodes": [
        {
            "id": "parallel_branch_executor",
            "type": "for_each",
            "config": {
                "items_key": "branch_configs",
                "item_variable": "current_branch",
                "output_key": "branch_results",
                "max_concurrency": 3,
                "nodes": [
                    {
                        "id": "branch_init",
                        "type": "operator",
                        "config": {
                            "code": "import time\n\nbranch_config = state.get('current_branch', {})\nbranch_id = branch_config.get('branch_id', 0)\nprompt = branch_config.get('prompt', 'Hello')\n\nstate['current_branch_id'] = branch_id\nstate['current_prompt'] = prompt\nstate['branch_start_time'] = int(time.time() * 1000)\nstate['branch_loop_count'] = 0\nstate['branch_llm_calls'] = 0\n\n# ì‹œì‘ íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë¡\nstate.setdefault('branch_start_timestamps', []).append(state['branch_start_time'])\n\nprint(f'ğŸŒ¿ ë¸Œëœì¹˜ {branch_id} ì‹œì‘: \"{prompt[:50]}...\"')",
                            "output_key": "branch_init_result"
                        }
                    },
                    {
                        "id": "branch_loop",
                        "type": "loop",
                        "config": {
                            "max_iterations": 2,
                            "condition": "state.get('branch_loop_count', 0) < state.get('max_loop_per_branch', 2)",
                            "nodes": [
                                {
                                    "id": "llm_branch_call",
                                    "type": "aiModel",
                                    "config": {
                                        "model": "gemini-2.0-flash",
                                        "provider": "gemini",
                                        "prompt_template": "{{ state.current_prompt }}\n\nProvide a concise, structured response in JSON format with:\n1. summary: A 2-3 sentence summary\n2. key_points: List of 3-5 key points\n3. confidence: Your confidence score (0-1)",
                                        "response_schema": {
                                            "type": "object",
                                            "properties": {
                                                "summary": {
                                                    "type": "string"
                                                },
                                                "key_points": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "string"
                                                    }
                                                },
                                                "confidence": {
                                                    "type": "number"
                                                }
                                            },
                                            "required": [
                                                "summary",
                                                "key_points",
                                                "confidence"
                                            ]
                                        },
                                        "output_key": "llm_branch_raw"
                                    }
                                },
                                {
                                    "id": "update_branch_state",
                                    "type": "operator",
                                    "config": {
                                        "code": "import json\n\nbranch_id = state.get('current_branch_id', 0)\nloop_count = state.get('branch_loop_count', 0) + 1\nstate['branch_loop_count'] = loop_count\nstate['branch_llm_calls'] = state.get('branch_llm_calls', 0) + 1\n\n# LLM ê²°ê³¼ íŒŒì‹±\nllm_raw = state.get('llm_branch_raw', '{}')\ntry:\n    if isinstance(llm_raw, str):\n        llm_result = json.loads(llm_raw)\n    else:\n        llm_result = llm_raw\nexcept:\n    llm_result = {'confidence': 0.7, 'summary': 'Parse failed'}\n\nstate['branch_confidence'] = llm_result.get('confidence', 0.7)\nstate['branch_summary'] = llm_result.get('summary', '')\nstate['branch_key_points'] = llm_result.get('key_points', [])\n\nprint(f'ğŸ”„ ë¸Œëœì¹˜ {branch_id} Loop {loop_count}: confidence={state[\"branch_confidence\"]:.2f}')",
                                        "output_key": "branch_loop_result"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "id": "check_branch_hitl",
                        "type": "operator",
                        "config": {
                            "code": "branch_id = state.get('current_branch_id', 0)\nhitl_at_branch = state.get('hitl_at_branch', 2)\n\nif branch_id == hitl_at_branch and state.get('hitl_enabled', True):\n    state['branch_hitl_required'] = True\n    print(f'â¸ï¸ ë¸Œëœì¹˜ {branch_id}ì—ì„œ HITL ë°œë™')\nelse:\n    state['branch_hitl_required'] = False",
                            "output_key": "branch_hitl_check"
                        }
                    },
                    {
                        "id": "branch_hitl",
                        "type": "hitl",
                        "config": {
                            "condition": "state.get('branch_hitl_required', False)",
                            "question": "ë¸Œëœì¹˜ ë¶„ì„ ê²°ê³¼ë¥¼ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                            "context_keys": [
                                "current_branch_id",
                                "branch_summary",
                                "branch_confidence"
                            ],
                            "auto_approve": true,
                            "auto_approve_delay_ms": 100,
                            "on_complete": {
                                "code": "branch_id = state.get('current_branch_id', 0)\nstate['hitl_events'].append({\n    'branch_id': branch_id,\n    'decision': 'approved'\n})\nprint(f'âœ… ë¸Œëœì¹˜ {branch_id} HITL ìŠ¹ì¸')"
                            }
                        }
                    },
                    {
                        "id": "finalize_branch",
                        "type": "operator",
                        "config": {
                            "code": "import time\n\nbranch_id = state.get('current_branch_id', 0)\nend_time = int(time.time() * 1000)\nstart_time = state.get('branch_start_time', end_time)\n\nusage = state.get('usage', {})\n\nresult = {\n    'branch_id': branch_id,\n    'status': 'completed',\n    'prompt': state.get('current_prompt', '')[:50],\n    'summary': state.get('branch_summary', ''),\n    'key_points': state.get('branch_key_points', []),\n    'confidence': state.get('branch_confidence', 0),\n    'loop_iterations': state.get('branch_loop_count', 0),\n    'llm_calls': state.get('branch_llm_calls', 0),\n    'usage': usage,  # ê°œë³„ usage - ì»¤ë„ì´ í‰íƒ„í™”(Flatten) í›„ í•©ì‚°\n    'latency_ms': end_time - start_time\n}\n\n# âš ï¸ race condition ë°©ì§€: aggregated_cost ì§ì ‘ ìˆ˜ì • ê¸ˆì§€!\n# ì»¤ë„ ë ˆë²¨ aggregatorê°€ branch_results[].usageë¥¼ ìë™ ì§‘ê³„í•¨\n\nprint(f'âœ… ë¸Œëœì¹˜ {branch_id} ì™„ë£Œ: {result[\"loop_iterations\"]} loops, confidence={result[\"confidence\"]:.2f}')\nstate['branch_final_result'] = result",
                            "output_key": "branch_result"
                        }
                    }
                ]
            }
        },
        {
            "id": "merge_statebag",
            "type": "operator",
            "config": {
                "code": "import time\n\nbranch_results = state.get('branch_results', [])\n\n# StateBag ë³‘í•©\nmerged = {\n    'branch_results': {},\n    'all_summaries': [],\n    'all_key_points': [],\n    'total_llm_calls': 0,\n    'max_confidence': 0\n}\n\nfor result in branch_results:\n    if isinstance(result, dict):\n        branch_id = result.get('branch_id', 0)\n        merged['branch_results'][str(branch_id)] = result\n        merged['all_summaries'].append(result.get('summary', ''))\n        merged['all_key_points'].extend(result.get('key_points', []))\n        merged['total_llm_calls'] += result.get('llm_calls', 0)\n        merged['max_confidence'] = max(merged['max_confidence'], result.get('confidence', 0))\n\nstate['merged_statebag'] = merged\n\nend_time = int(time.time() * 1000)\nstate['parallel_end_time'] = end_time\nstate['total_latency_ms'] = end_time - state.get('parallel_start_time', end_time)\n\nprint(f'âœ… StateBag ë³‘í•© ì™„ë£Œ: {len(merged[\"branch_results\"])} branches, {merged[\"total_llm_calls\"]} LLM calls')",
                "output_key": "merge_result"
            }
        },
        {
            "id": "final_verification",
            "type": "operator",
            "config": {
                "code": "branch_results = state.get('branch_results', [])\nexpected = state.get('parallel_branches', 5)\ncompleted = len([b for b in branch_results if isinstance(b, dict) and b.get('status') == 'completed'])\n\nhitl_count = len(state.get('hitl_events', []))\nmerged = state.get('merged_statebag', {})\n\n# ì»¤ë„ aggregatorê°€ ì§‘ê³„í•œ usage ì‚¬ìš© (ê°œë³„ branch ê²°ê³¼ì—ì„œ í‰íƒ„í™”)\ntotal_cost = 0\ntotal_tokens = 0\nfor b in branch_results:\n    if isinstance(b, dict):\n        usage = b.get('usage', {})\n        total_cost += usage.get('cost', 0)\n        total_tokens += usage.get('total_tokens', usage.get('input_tokens', 0) + usage.get('output_tokens', 0))\n\n# StateBag ë³‘í•© ë¬´ê²°ì„± ê²€ì¦\nmerged_branch_count = len(merged.get('branch_results', {}))\nloss_detected = completed != merged_branch_count\n\n# S3 ì˜¤í”„ë¡œë”© ì—¬ë¶€ í™•ì¸\ns3_offloaded = state.get('_s3_offload_triggered', False)\nstate_size_kb = len(str(state)) // 1024\n\nif completed >= expected and not loss_detected:\n    state['TEST_RESULT'] = f'âœ… STAGE7 SUCCESS: {completed}/{expected} branches, {hitl_count} HITLs, ${total_cost:.4f}, {total_tokens} tokens, 0% loss, S3={s3_offloaded} ({state_size_kb}KB)'\nelse:\n    state['TEST_RESULT'] = f'âŒ STAGE7 ISSUES: {completed}/{expected} branches, loss={loss_detected}'\n\nprint(state['TEST_RESULT'])",
                "output_key": "verification_result"
            }
        }
    ],
    "edges": [
        {
            "source": "parallel_branch_executor",
            "target": "merge_statebag"
        },
        {
            "source": "merge_statebag",
            "target": "final_verification"
        }
    ],
    "start_node": "parallel_branch_executor",
    "initial_state": {
        "test_stage": 7,
        "parallel_branches": 5,
        "max_concurrency": 3,
        "max_loop_per_branch": 2,
        "hitl_enabled": true,
        "hitl_at_branch": 2,
        "verify_statebag_merge_integrity": true,
        "expected_zero_loss": true,
        "verify_cost_aggregation": true,
        "dummy_content_size_kb": 2,
        "s3_offload_threshold_kb": 180,
        "verify_s3_offload": true,
        "branch_configs": [
            {
                "branch_id": 0,
                "prompt": "Summarize the key benefits of cloud computing. Context: Dummy data..."
            },
            {
                "branch_id": 1,
                "prompt": "List 3 security best practices for AWS Lambda. Context: Dummy data..."
            },
            {
                "branch_id": 2,
                "prompt": "Explain serverless architecture in simple terms. Context: Dummy data..."
            },
            {
                "branch_id": 3,
                "prompt": "Compare containers vs serverless for microservices. Context: Dummy data..."
            },
            {
                "branch_id": 4,
                "prompt": "Describe event-driven architecture patterns. Context: Dummy data..."
            }
        ],
        "branch_results": [],
        "hitl_events": [],
        "branch_start_timestamps": [],
        "merged_statebag": {}
    }
}