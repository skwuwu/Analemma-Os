import { ScrollArea } from '@/components/ui/scroll-area';
import { Button } from '@/components/ui/button';
import { FileJson, Trash2, Play, Loader2, Eye, ChevronRight, Activity } from 'lucide-react';
import { toast } from 'sonner';
import { WorkflowChat } from './WorkflowChat';
import { CloneInstructionsDialog } from './CloneInstructionsDialog';
import { useWorkflowStore } from '@/lib/workflowStore';
import { useWorkflowApi } from '@/hooks/useWorkflowApi';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import { useState, useRef, useLayoutEffect, useMemo } from 'react';
import { convertWorkflowToBackendFormat, convertWorkflowFromBackendFormat, type BackendWorkflow } from '@/lib/workflowConverter';

import { TEST_KEYWORD_DESCRIPTIONS, BUILD_TIME_TEST_KEYWORDS } from '@/lib/testConstants';
import { Node, Edge } from '@xyflow/react';
import { parseInitialState } from '@/lib/utils';
import { Badge } from '@/components/ui/badge';

// 타입 정의
interface WorkflowData {
  id?: string;
  workflowId?: string;
  name?: string;
  nodes: Node[];
  edges: Edge[];
  inputs?: Record<string, any>;
  source_file?: string;
  created_at?: string;
}

export const SavedWorkflows = ({
  currentWorkflow,
  onLoadWorkflow,
}: {
  currentWorkflow?: WorkflowData;
  onLoadWorkflow?: (workflow: WorkflowData) => void;
}) => {
  const { clearWorkflow, loadWorkflow, subgraphs } = useWorkflowStore();
  const {
    workflows,
    isLoading,
    hasMoreWorkflows,
    loadMoreWorkflows,
    isLoadingMore,
    saveWorkflowAsync,
    deleteWorkflow,
    runWorkflowAsync,
    isRunning,
    getWorkflowByName,
    isLoadingWorkflow,
    cloneInstructions,
    isCloningInstructions,
  } = useWorkflowApi();

  const [workflowName, setWorkflowName] = useState('');
  const [showWorkflows, setShowWorkflows] = useState(false);
  const savedListRef = useRef<HTMLDivElement | null>(null);

  // 로드 및 미리보기 관련 상태
  const [selectedWorkflow, setSelectedWorkflow] = useState<{ name: string; workflowId?: string; data?: any; metadata?: Record<string, any> } | null>(null);
  const [showLoadDialog, setShowLoadDialog] = useState(false);
  const [showPreviewDialog, setShowPreviewDialog] = useState(false);
  const [previewData, setPreviewData] = useState<WorkflowData | null>(null);

  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [workflowToDelete, setWorkflowToDelete] = useState<{ id: string; name: string } | null>(null);
  const [showInitialStateDialog, setShowInitialStateDialog] = useState(false);
  const [initialStateText, setInitialStateText] = useState('');
  const [workflowAlias, setWorkflowAlias] = useState('');

  // Clone Instructions Dialog 상태
  const [showCloneDialog, setShowCloneDialog] = useState(false);
  const [savedWorkflowId, setSavedWorkflowId] = useState<string | null>(null);
  const [savedWorkflowName, setSavedWorkflowName] = useState<string>('');

  // 자동 생성될 별칭 계산
  const autoGeneratedAlias = useMemo(() => {
    if (workflowAlias.trim()) return null; // 사용자가 직접 입력한 경우 표시하지 않음
    if (!initialStateText.trim()) return null;
    const firstWord = initialStateText.trim().split(/\s+/)[0];
    return firstWord || 'Workflow';
  }, [workflowAlias, initialStateText]);

  const handleSave = async () => {
    if (!currentWorkflow || (!currentWorkflow.nodes?.length && !currentWorkflow.edges?.length)) {
      toast.error('No workflow to save');
      return;
    }

    // subgraphs를 포함한 완전한 워크플로우 객체 생성
    const workflowWithSubgraphs = {
      ...currentWorkflow,
      subgraphs: subgraphs || {},
    };

    const config: BackendWorkflow = convertWorkflowToBackendFormat(workflowWithSubgraphs);
    const name = (workflowName && workflowName.trim()) ? workflowName.trim() : (currentWorkflow.name || config.name || 'untitled');
    config.name = name;
    const is_scheduled = false;
    const next_run_time = null;

    try {
      let serverId: string | null = null;
      const isNewWorkflow = !currentWorkflow.id;

      if (currentWorkflow.id) {
        await saveWorkflowAsync({ workflowId: currentWorkflow.id, config, is_scheduled, next_run_time, name } as any);
        serverId = currentWorkflow.id;
      } else {
        const result = await saveWorkflowAsync({ config, is_scheduled, next_run_time, name } as any) as { workflowId?: string; id?: string } | undefined;
        serverId = result?.workflowId || result?.id || null;
      }

      if (onLoadWorkflow) {
        try {
          const fullWorkflowData = { ...currentWorkflow, id: serverId || currentWorkflow.id || crypto.randomUUID(), name };
          onLoadWorkflow(fullWorkflowData);
        } catch (e) { console.warn('Propagate failed', e); }
      }

      // 새 워크플로우인 경우 Clone Instructions Dialog 표시
      if (isNewWorkflow && serverId && workflows.length > 0) {
        setSavedWorkflowId(serverId);
        setSavedWorkflowName(name);
        setShowCloneDialog(true);
      }
    } catch (e) {
      console.error('Save failed:', e);
      toast.error('Failed to save workflow');
      return;
    }
    setWorkflowName('');
  };

  // Clone Instructions 핸들러
  const handleCloneConfirm = async (sourceWorkflowId: string | null) => {
    if (sourceWorkflowId && savedWorkflowId) {
      try {
        await cloneInstructions({
          sourceWorkflowId,
          targetWorkflowId: savedWorkflowId,
        });
      } catch (e) {
        console.error('Clone instructions failed:', e);
      }
    }
    setShowCloneDialog(false);
    setSavedWorkflowId(null);
    setSavedWorkflowName('');
  };

  const handleDeleteClick = (workflowId: string, workflowName: string) => {
    if (!workflowId) { toast.error('ID missing'); return; }
    setWorkflowToDelete({ id: workflowId, name: workflowName });
    setShowDeleteDialog(true);
  };
  const handleDeleteConfirm = () => { if (workflowToDelete?.id) deleteWorkflow(workflowToDelete.id); setShowDeleteDialog(false); setWorkflowToDelete(null); };
  const handleDeleteCancel = () => { setShowDeleteDialog(false); setWorkflowToDelete(null); };

  const handleRun = () => {
    if (!currentWorkflow || (!currentWorkflow.nodes?.length && !currentWorkflow.edges?.length)) { toast.error('No workflow to run'); return; }
    const hasRequestTrigger = !!currentWorkflow.nodes?.some((n: any) => { if (n.type !== 'trigger') return false; return n.data?.triggerType === 'request' || n.data?.blockId === 'request'; });
    if (hasRequestTrigger) {
      try {
        const existing = currentWorkflow.inputs?.user_prompt ?? currentWorkflow.inputs ?? '';
        const prefill = typeof existing === 'string' ? existing : (typeof currentWorkflow.inputs === 'string' ? currentWorkflow.inputs : '');
        setInitialStateText(prefill || '');
      } catch { setInitialStateText(''); }
      setShowInitialStateDialog(true);
      return;
    }
    executeRun(currentWorkflow.inputs || {});
  };

  const executeRun = async (inputs: Record<string, unknown>) => {
    const runWithId = async (id: string) => { try { await runWorkflowAsync({ workflowId: id, inputs }); } catch (e) { console.error('Run failed:', e); } };
    let workflowId = currentWorkflow.id || currentWorkflow.workflowId;
    if (!workflowId) {
      toast.info('Saving workflow before running...');
      try {
        const config: BackendWorkflow = convertWorkflowToBackendFormat(currentWorkflow);
        const name = (workflowName && workflowName.trim()) ? workflowName.trim() : (currentWorkflow.name || config.name || 'untitled');
        config.name = name;
        const result = await saveWorkflowAsync({ config, is_scheduled: false, next_run_time: null, name }) as { workflowId?: string; id?: string } | undefined;
        workflowId = result?.workflowId || result?.id || null;
        if (!workflowId) { toast.error('Failed to obtain ID'); return; }
        if (onLoadWorkflow) onLoadWorkflow({ ...currentWorkflow, id: workflowId, name });
      } catch (e) { toast.error('Auto-save failed'); return; }
    }
    if (!workflowId) { toast.error('ID missing'); return; }
    await runWithId(workflowId as string);
  };

  const fetchWorkflowDetails = async (name: string) => {
    try {
      const detail = await getWorkflowByName(name);
      const config = detail?.config;
      if (!config) throw new Error('Workflow configuration missing');
      return { name, data: config, metadata: { ...detail, workflowId: detail.workflowId } };
    } catch (error) {
      console.error('Failed to fetch details:', error);
      toast.error(`Failed to load: ${name}`);
      throw error;
    }
  };

  // [수정] 미리보기 모드 핸들러
  const handleViewWorkflow = async (workflow: { name: string; workflowId?: string }) => {
    try {
      const details = await fetchWorkflowDetails(workflow.name);
      const frontendWorkflow = convertWorkflowFromBackendFormat(details.data);
      setSelectedWorkflow(workflow);
      setPreviewData({ ...frontendWorkflow, id: details.metadata.workflowId, name: workflow.name });
      setShowPreviewDialog(true);
    } catch (error) { /* handled in fetchWorkflowDetails */ }
  };

  // [수정] 더블 클릭은 바로 로드 확인창
  const handleWorkflowDoubleClick = (workflow: { name: string; workflowId?: string }) => {
    setSelectedWorkflow(workflow);
    setShowLoadDialog(true);
  };

  const handleLoadConfirm = async () => {
    const targetWorkflow = selectedWorkflow || (previewData ? { name: previewData.name || '', workflowId: previewData.id } : null);
    if (targetWorkflow) {
      try {
        let workflowData;
        if (previewData && previewData.name === targetWorkflow.name) {
          workflowData = { data: convertWorkflowToBackendFormat(previewData), metadata: { workflowId: previewData.id } };
        } else if (selectedWorkflow?.data) {
          workflowData = selectedWorkflow;
        } else {
          workflowData = await fetchWorkflowDetails(targetWorkflow.name);
        }

        const frontendWorkflow = convertWorkflowFromBackendFormat(workflowData.data);

        clearWorkflow();
        loadWorkflow(frontendWorkflow);

        if (onLoadWorkflow) {
          const fullWorkflowData = { ...frontendWorkflow, id: targetWorkflow.workflowId, name: targetWorkflow.name };
          onLoadWorkflow(fullWorkflowData);
        }

        toast.success(`Loaded workflow: ${targetWorkflow.name}`);
      } catch (error) {
        console.error('Failed to load workflow:', error);
      }
    }
    setShowLoadDialog(false);
    setShowPreviewDialog(false);
    setSelectedWorkflow(null);
    setPreviewData(null);
  };

  const handleLoadCancel = () => { setShowLoadDialog(false); setSelectedWorkflow(null); };
  const handlePreviewClose = () => { setShowPreviewDialog(false); setPreviewData(null); setSelectedWorkflow(null); };

  const handleInitialStateCancel = () => { setShowInitialStateDialog(false); setInitialStateText(''); setWorkflowAlias(''); };
  const handleInitialStateConfirm = async () => {
    const userInput = (initialStateText ?? '').trim();
    const inputs = parseInitialState(userInput, currentWorkflow);
    let finalAlias = workflowAlias.trim();
    if (!finalAlias && userInput) {
      // 별칭이 없으면 initial state의 첫 단어를 사용
      const firstWord = userInput.split(/\s+/)[0];
      finalAlias = firstWord || 'Workflow';
    }
    if (finalAlias) {
      inputs.workflow_alias = finalAlias;
    }
    setShowInitialStateDialog(false);
    setInitialStateText('');
    setWorkflowAlias('');
    await executeRun(inputs);
  };

  useLayoutEffect(() => { if (!showWorkflows) return; try { if (savedListRef.current) savedListRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch { } }, [showWorkflows]);

  return (
    <div className="h-full bg-card border-l border-border p-4 flex flex-col">
      <h2 className="text-lg font-bold mb-4 text-foreground">Saved Workflows</h2>

      <div className="space-y-2 mb-4">
        <Input placeholder="Workflow name (optional)" value={workflowName} onChange={(e) => setWorkflowName(e.target.value)} className="h-9 text-sm" />
        <Button onClick={handleSave} className="w-full bg-primary hover:bg-primary/90" disabled={isLoading}>Save Current</Button>
        <Button onClick={handleRun} variant="secondary" className="w-full" disabled={isRunning}>{isRunning ? <><Loader2 className="w-4 h-4 mr-2 animate-spin" />Running...</> : <><Play className="w-4 h-4 mr-2" />Run Workflow</>}</Button>
        <Button onClick={() => setShowWorkflows(!showWorkflows)} variant="outline" className="w-full"><Eye className="w-4 h-4 mr-2" />{showWorkflows ? 'Hide' : 'View My Workflows'}</Button>
      </div>

      {showWorkflows && (
        <div ref={savedListRef}>
          <ScrollArea className="flex-1 mb-4">
            <div className="space-y-2">
              {isLoading ? (
                <div className="text-center py-8 text-muted-foreground text-sm"><Loader2 className="w-4 h-4 mx-auto mb-2 animate-spin" /> Loading workflows...</div>
              ) : workflows.length === 0 ? (
                <div className="text-center py-8 text-muted-foreground text-sm">No saved workflows yet</div>
              ) : (
                workflows.map((workflow) => (
                  <div key={workflow.workflowId || workflow.name} className="p-3 rounded-lg border border-border bg-secondary hover:bg-secondary/80 transition-colors cursor-pointer group" onDoubleClick={() => handleWorkflowDoubleClick(workflow)}>
                    <div className="flex items-start justify-between">
                      <div className="flex items-start gap-2 flex-1">
                        <FileJson className="w-4 h-4 text-primary mt-0.5" />
                        <div className="flex-1 min-w-0">
                          <div className="font-medium text-sm text-foreground truncate">{workflow.name}</div>
                          <div className="text-xs text-muted-foreground flex items-center gap-1 group-hover:text-foreground/70 transition-colors">Double-click to load<ChevronRight className="w-3 h-3" /></div>
                        </div>
                      </div>
                      <div className="flex gap-1">
                        <Button variant="ghost" size="sm" onClick={(e) => { e.stopPropagation(); handleViewWorkflow(workflow); }} className="h-8 w-8 p-0"><Eye className="w-3 h-3" /></Button>
                        <Button variant="ghost" size="sm" onClick={(e) => { e.stopPropagation(); if (workflow.workflowId) handleDeleteClick(workflow.workflowId, workflow.name); else toast.error('Cannot delete: Workflow ID missing'); }} className="h-8 w-8 p-0 hover:bg-destructive/20" disabled={!workflow.workflowId}><Trash2 className="w-3 h-3 text-destructive" /></Button>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
            {hasMoreWorkflows && (<div className="pt-3"><Button onClick={() => loadMoreWorkflows().catch(() => undefined)} variant="ghost" className="w-full" disabled={isLoadingMore}>{isLoadingMore ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : 'Load more workflows'}</Button></div>)}
          </ScrollArea>
        </div>
      )}



      <div className="h-64 border-t border-border"><WorkflowChat onWorkflowUpdate={onLoadWorkflow} /></div>

      {/* 1. Preview Dialog (새로 추가됨) */}
      <AlertDialog open={showPreviewDialog} onOpenChange={setShowPreviewDialog}>
        <AlertDialogContent className="max-w-2xl">
          <AlertDialogHeader>
            <div className="flex items-center justify-between">
              <AlertDialogTitle className="flex items-center gap-2"><FileJson className="w-5 h-5 text-primary" />Preview: {selectedWorkflow?.name}</AlertDialogTitle>
              {previewData && (<Badge variant="outline" className="text-xs font-normal">ID: {previewData.id?.slice(0, 8)}...</Badge>)}
            </div>
            <AlertDialogDescription>Review details before loading. Loading will replace your current canvas.</AlertDialogDescription>
          </AlertDialogHeader>

          {previewData ? (
            <div className="grid grid-cols-2 gap-4 py-4">
              <div className="space-y-4">
                <div className="bg-secondary/50 p-3 rounded-md border">
                  <h4 className="text-sm font-semibold mb-2 flex items-center gap-2"><Activity className="w-4 h-4" /> Statistics</h4>
                  <div className="text-sm space-y-1 text-muted-foreground">
                    <p>Nodes: <span className="text-foreground font-medium">{previewData.nodes.length}</span></p>
                    <p>Edges: <span className="text-foreground font-medium">{previewData.edges.length}</span></p>
                    {previewData.created_at && (
                      <p className="pt-1 mt-1 border-t border-border/50 text-xs flex items-center gap-1">
                        Created:
                        <span className="text-foreground font-medium">{new Date(previewData.created_at).toLocaleDateString()}</span>
                      </p>
                    )}
                  </div>
                </div>
              </div>
              <div className="space-y-4">
                <div className="bg-secondary/50 p-3 rounded-md border h-full">
                  <h4 className="text-sm font-semibold mb-2">Input Configuration</h4>
                  <pre className="text-xs bg-background p-2 rounded border overflow-auto max-h-[100px]">{JSON.stringify(previewData.inputs || {}, null, 2)}</pre>
                </div>
              </div>
              <div className="col-span-2">
                <h4 className="text-sm font-semibold mb-2">Structure Preview</h4>
                <div className="flex flex-wrap gap-2">
                  {previewData.nodes.slice(0, 10).map((node: any) => (<Badge key={node.id} variant="secondary" className="text-xs">{node.type}</Badge>))}
                  {previewData.nodes.length > 10 && <span className="text-xs text-muted-foreground">+{previewData.nodes.length - 10} more</span>}
                </div>
              </div>
            </div>
          ) : (
            <div className="py-8 flex justify-center"><Loader2 className="w-8 h-8 animate-spin text-primary" /></div>
          )}

          <AlertDialogFooter>
            <AlertDialogCancel onClick={handlePreviewClose}>Close</AlertDialogCancel>
            <AlertDialogAction onClick={handleLoadConfirm} disabled={!previewData}>Load to Canvas</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 2. Load Confirm Dialog (기존 유지 - 더블클릭 시 사용) */}
      <AlertDialog open={showLoadDialog} onOpenChange={setShowLoadDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Load Workflow</AlertDialogTitle>
            <AlertDialogDescription>Loading "{selectedWorkflow?.name}" will clear the current canvas and replace it with the saved workflow. Any unsaved changes will be lost. Are you sure you want to continue?</AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleLoadCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleLoadConfirm} disabled={isLoadingWorkflow}>{isLoadingWorkflow ? <><Loader2 className="w-4 h-4 mr-2 animate-spin" /> Loading...</> : 'Load Workflow'}</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 3. Delete Dialog (기존 유지) */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Workflow</AlertDialogTitle>
            <AlertDialogDescription>Are you sure you want to delete "{workflowToDelete?.name}"? This action cannot be undone.</AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleDeleteCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleDeleteConfirm} className="bg-destructive hover:bg-destructive/90">Delete</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 4. Initial State Dialog (기존 유지) */}
      <AlertDialog open={showInitialStateDialog} onOpenChange={setShowInitialStateDialog}>
        <AlertDialogContent className="max-w-2xl">
          <AlertDialogHeader>
            <AlertDialogTitle>Run: Initial Prompt</AlertDialogTitle>
            <AlertDialogDescription>Enter a natural-language prompt to start the workflow.</AlertDialogDescription>
          </AlertDialogHeader>
          <div className="mt-2 space-y-4">
            <div>
              <label className="text-sm font-semibold mb-2 block">Workflow Alias (Optional)</label>
              <Input placeholder='e.g. "Stock Analysis - Tech Sector"' value={workflowAlias} onChange={(e) => setWorkflowAlias(e.target.value)} className="w-full text-sm" />
              {autoGeneratedAlias && (
                <p className="text-xs text-muted-foreground mt-1">
                  If not specified, will be saved as: <code className="bg-secondary px-1 py-0.5 rounded text-xs">{autoGeneratedAlias}</code>
                </p>
              )}
            </div>
            <div>
              <label className="text-sm font-semibold mb-2 block">Initial Prompt</label>
              <Textarea placeholder='e.g. "내 구글 드라이브 요약해줘"' value={initialStateText} onChange={(e) => setInitialStateText(e.target.value)} className="min-h-[120px] w-full text-sm" />
            </div>
            <div>
              <h4 className="text-sm font-semibold mb-2">Supported Test Keywords</h4>
              <div className="grid grid-cols-1 gap-2 max-h-40 overflow-y-auto">
                {BUILD_TIME_TEST_KEYWORDS.map((keyword) => (
                  <div key={keyword} className="flex justify-between items-center p-2 bg-secondary rounded text-sm">
                    <code className="font-mono text-primary">{keyword}</code>
                    <span className="text-muted-foreground text-xs ml-2">
                      {TEST_KEYWORD_DESCRIPTIONS[keyword as keyof typeof TEST_KEYWORD_DESCRIPTIONS] || '테스트 키워드'}
                    </span>
                  </div>
                ))}
              </div>
            </div>
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={handleInitialStateCancel}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleInitialStateConfirm} className="bg-primary hover:bg-primary/90">Run</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 5. Clone Instructions Dialog (새로 추가됨) */}
      <CloneInstructionsDialog
        open={showCloneDialog}
        onOpenChange={setShowCloneDialog}
        workflows={workflows}
        onConfirm={handleCloneConfirm}
        isCloning={isCloningInstructions}
        targetWorkflowName={savedWorkflowName}
      />
    </div>
  );
};
